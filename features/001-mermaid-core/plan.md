# План Реализации: Генератор Диаграмм Mermaid

## 1. Обзор Архитектуры

Система будет следовать клиент-центричной архитектуре. Основная логика для генерации, валидации и исправления диаграмм Mermaid будет находиться в клиентском JavaScript-приложении, которое напрямую общается с локальным экземпляром `cliproxyapi`. Минимальный бэкенд-сервер будет использоваться в основном для раздачи статических веб-ресурсов.

```mermaid
graph TD
    Пользователь -->|1. Промпт| Браузер
    Браузер -->|2. HTTP-запрос (Промпт, Текущая диаграмма)| Локальный_cliproxyapi(Локальный прокси cliproxyapi)
    Локальный_cliproxyapi -->|3. Вызов API LLM (с ключами пользователя)| LLM(Большая Языковая Модель)
    LLM -->|4. Ответ с кодом Mermaid| Локальный_cliproxyapi
    Локальный_cliproxyapi -->|5. Ответ с кодом Mermaid| Браузер
    Браузер -->|6. Валидация кода| JS_Валидатор(JavaScript Валидатор)
    JS_Валидатор -->|7a. Валидно| Рендеринг(Рендеринг диаграммы)
    JS_Валидатор -->|7b. Невалидно (Попыток < Макс)| Браузер
    Браузер -->|8. Формирование корректирующего промпта| Браузер
    Браузер -->|2. HTTP-запрос (Корректирующий промпт, Невалидный код)| Локальный_cliproxyapi
    JS_Валидатор -->|7c. Невалидно (Попыток >= Макс)| Отображение_Ошибки(Показать ошибку пользователю)
```

## 2. Технический Стек

*   **Фронтенд:** HTML, CSS, JavaScript (ES6+), библиотека Mermaid.js (для рендеринга).
*   **Бэкенд (Минимальный):** Любой сервер для статических файлов (например, Node.js с Express, Python с Flask или Nginx).
*   **Взаимодействие с LLM:** `cliproxyapi` (локальное прокси-приложение).

## 3. Стандарты Кода и Тестирование

Для обеспечения высокого качества и консистентности кода, проект будет придерживаться следующих стандартов.

### 3.1. Линтинг и Форматирование

*   **Линтер:** Будет использоваться [ESLint](https://eslint.org/) для статического анализа кода и выявления проблем.
*   **Форматирование кода:** Будет использоваться [Prettier](https://prettier.io/) для автоматического форматирования кода, чтобы гарантировать единый стиль.
*   **Интеграция:** ESLint и Prettier будут настроены для совместной работы.

### 3.2. Тестирование

*   **Фреймворк:** Для юнит-тестирования логики будет использоваться [Vitest](https://vitest.dev/) как современный и быстрый инструмент.
*   **Что тестируем:** Основное внимание будет уделено функциям в `app.js`:
    *   **`validateMermaidCode()`:** Проверка на корректную обработку валидного и невалидного кода.
    *   **`callCliproxyApi()`:** Тестирование с имитацией (mock) `fetch`-запросов.
    *   **`generateAndCorrectDiagram()`:** Проверка логики цикла исправлений и лимита попыток.

## 4. Компоненты

### 3.1. Фронтенд-приложение (`public/index.html` и `public/app.js`)

*   **`index.html`:**
    *   Служит основной точкой входа.
    *   Включает необходимые CSS (например, для базовой стилизации).
    *   Включает библиотеку `mermaid.js` (через CDN) для рендеринга диаграмм.
    *   Включает `app.js` для всей логики приложения.
    *   **Элементы UI:**
        *   Textarea для ввода промпта пользователя.
        *   Кнопка для запуска процесса генерации/улучшения.
        *   Контейнер (`div`) для визуального рендеринга диаграммы Mermaid.
        *   Область для отображения статусных сообщений, ошибок валидации и обратной связи для пользователя.

*   **`app.js`:**
    *   **Управление состоянием:**
        *   `currentDiagramCode`: Хранит последний валидный код отображаемой диаграммы.
        *   `originalUserPrompt`: Хранит начальный промпт для контекста в циклах исправления.
        *   `retryCount`: Отслеживает попытки в цикле исправления.
        *   `maxRetries`: Константа (по умолчанию 5) для ограничения количества попыток исправления.
    *   **Функция `generateAndCorrectDiagram(userPrompt)`:**
        *   Оркестрирует весь процесс.
        *   Принимает текущий промпт пользователя в качестве входных данных.
        *   Управляет циклом повторных попыток.
        *   Обновляет UI в зависимости от статуса (загрузка, валидация, исправление, успех, сбой).
    *   **Функция `callCliproxyApi(promptMessage, contextDiagramCode)`:**
        *   Создает конкретный промпт для LLM (начальная генерация или исправление) на основе `promptMessage` и `contextDiagramCode`.
        *   Отправляет `fetch`-запрос на локальный `cliproxyapi` (OpenAI-совместимый endpoint, например, `http://localhost:8317/v1/chat/completions`).
        *   Обрабатывает сетевые ошибки и парсинг ответа.
        *   Возвращает исходный код Mermaid от LLM.
    *   **Функция `validateMermaidCode(code)`:**
        *   Использует `mermaid.parse()` (предоставляемый `mermaid.js`) для проверки синтаксических ошибок.
        *   Может быть расширена для включения базовых структурных проверок (например, проверка наличия ключевого слова `graph`, обеспечение того, что узлы определены и соединены).
        *   Возвращает объект: `{ isValid: boolean, errors: string[] }`.
    *   **Функции обновления UI:**
        *   `renderMermaidDiagram(code)`: Принимает код Mermaid и обновляет область визуальной диаграммы.
        *   `displayStatus(message, type)`: Показывает статусные/ошибочные сообщения пользователю.
    *   **Слушатели событий:** Привязан к кнопке "Сгенерировать" для вызова `generateAndCorrectDiagram`.

### 3.2. Бэкенд-сервер

*   **Назначение:** В основном для раздачи статических файлов (например, `index.html`, `app.js`, `style.css`).
*   **Технология:** Простой HTTP-сервер (например, `http-server` NPM-пакет, `http.server` в Python или базовое приложение Express/Flask для большего контроля).
*   **Отсутствие API:** Этот сервер не будет предоставлять никаких API для генерации диаграмм или взаимодействия с LLM. Все динамическое взаимодействие будет на стороне клиента с `cliproxyapi`.

### 3.3. Локальный прокси `cliproxyapi`

*   **Предполагаемая функциональность:**
    *   Прослушивает локальный порт (например, `http://localhost:port`).
    *   Принимает HTTP-запросы, содержащие промпты для LLM.
    *   Управляет аутентификацией пользователя и использованием токенов для фактического провайдера LLM.
    *   Перенаправляет промпты в LLM.
    *   Возвращает ответы LLM (код Mermaid) обратно клиенту.
    *   Должен быть настроен для разрешения Cross-Origin Resource Sharing (CORS) с домена, на котором размещено наше веб-приложение (например, `Access-Control-Allow-Origin: *` для разработки или конкретный домен для продакшена).
